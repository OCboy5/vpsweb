# Project Specification: Central Poetry Translation Repository for vpsweb

## 1. Project Overview

This document outlines the plan to create a central repository for the poetry translations generated by the `vpsweb` tool. The goal is to build a system that enables easy classification, searching, and access for a growing collection of translated poems. The final product will be a low-network-volume niche website with a clear, performant, and maintainable architecture.

## 2. Guiding Principles

*   **Simplicity and Maintainability:** The initial system should be simple to build and manage, using a minimal and robust tech stack.
*   **Data-Centric Design:** The core focus is on a well-defined data structure. A rich metadata schema is crucial for the project's success.
*   **Decoupled Architecture:** The data storage, API, and user interface will be developed as separate, independent components to ensure flexibility and scalability.

## 3. System Architecture

The system will be composed of three primary layers: a **Data Storage Layer**, an **API Access Layer**, and a **Web UI Presentation Layer**.

### 3.1. Phase 1: Data Storage Layer

This layer is responsible for the persistent storage of poems and their associated metadata.

*   **Database Technology:** **SQLite**
    *   **Reasoning:** SQLite is a lightweight, serverless, self-contained database that is ideal for a low-traffic, niche application. It simplifies development and deployment by storing the entire database in a single file, which can be easily versioned and managed alongside the application code.

*   **Core Data Schema:**
    The primary table will be named `poems`. Each record in this table represents a single translated poem and will contain the following fields:

| Field Name | Data Type | Description | Example |
| :--- | :--- | :--- | :--- |
| `id` | INTEGER | Primary Key, Auto-incrementing. | `101` |
| `poem_uuid` | TEXT | A unique identifier (UUID v4) for API access. | `'a1b2c3d4-...'` |
| `original_title` | TEXT | The title in the source language. | `'Le Lac'` |
| `translated_title` | TEXT | The title in the target language. | `'The Lake'` |
| `source_language` | TEXT | ISO 639-1 code for the source language. | `'fr'` |
| `target_language` | TEXT | ISO 639-1 code for the target language. | `'en'` |
| `original_author` | TEXT | Name of the original poet. | `'Alphonse de Lamartine'` |
| `translator` | TEXT | Name of the translator. | `'AI Translator (vpsweb)'` |
| `editor` | TEXT | Name of the editor (can be NULL). | `'John Doe'` |
| `original_text` | TEXT | Full text of the source poem. | `'Ainsi, toujours pouss√©s... '` |
| `translated_text` | TEXT | Full text of the translated poem. | `'Thus, forever driven... '` |
| `tags` | TEXT | A comma-separated string of keywords. | `'romanticism,nature,lake'` |
| `vpsweb_mode` | TEXT | The `vpsweb` workflow mode used. | `'Reasoning'` |
| `vpsweb_version` | TEXT | Version of the `vpsweb` tool used. | `'1.2.0'` |
| `line_by_line_json`| TEXT | JSON string storing line comparisons. | `'[{"orig": "line1", "trans": "line1_t"}]'`|
| `created_at` | TEXT | ISO 8601 timestamp of record creation. | `'2025-10-07T15:30:00Z'` |

### 3.2. Phase 2: API Access Layer

A simple, fast REST API will serve the data from the SQLite database.

*   **Framework:** **FastAPI**
    *   **Reasoning:** FastAPI is a modern, high-performance Python framework that is easy to learn and includes automatic interactive API documentation (via Swagger UI and ReDoc), which is excellent for development and testing.

*   **Core API Endpoints:**

    *   **`GET /poems`**
        *   **Description:** Retrieve a paginated list of all poems.
        *   **Query Parameters:** `?page=1&per_page=20`
        *   **Returns:** A JSON object with a list of poem summaries (e.g., id, titles, author, tags).

    *   **`GET /poems/{poem_uuid}`**
        *   **Description:** Retrieve the full details for a single poem by its UUID.
        *   **Returns:** A JSON object with all fields for the specified poem.

    *   **`GET /search`**
        *   **Description:** Search for poems based on a query string. The search should target titles, authors, and the full text.
        *   **Query Parameters:** `?q=love&lang=en&tag=nature`
        *   **Returns:** A JSON array of poems matching the search criteria.

    *   **`GET /tags`**
        *   **Description:** Retrieve a list of all unique tags used across all poems.
        *   **Returns:** A JSON array of strings. `["romanticism", "nature", "sonnet"]`

### 3.3. Phase 3: Web UI Presentation Layer

The user-facing website will be a fast, static site that consumes data from the API.

*   **Technology:** **Static Site Generator (SSG)**
    *   **Recommendation:** **Pelican** (Python-based) or **Hugo** (Go-based).
    *   **Reasoning:** An SSG provides excellent performance, high security, and low hosting costs, which is perfect for a niche website. The site content is pre-generated into static HTML/CSS/JS files.

*   **Required Pages & Features:**
    1.  **Homepage:** A clean, paginated list of the most recent translated poems.
    2.  **Poem Detail Page:** A page dedicated to displaying a single poem, showing the original and translated texts side-by-side, along with all metadata (author, translator, tags, etc.).
    3.  **Search Page:** An interactive search page with a search bar. The search functionality will be powered by client-side JavaScript that calls the `/search` endpoint of the API and dynamically displays the results.
    4.  **Tags Page:** A page that lists all available tags, allowing users to click a tag to see all poems associated with it.

### 4. Phase 4: Integration with `vpsweb`

The `vpsweb` application must be updated to write its output to the newly created database.

*   **Workflow:**
    1.  After a successful translation and editing process, `vpsweb` will gather all relevant metadata.
    2.  It will connect to the **SQLite** database file.
    3.  It will execute an `INSERT` SQL command to save the new poem record into the `poems` table.

## 5. Implementation Plan

1.  **Step 1: Database Setup**
    *   Write a Python script (`init_db.py`) to create the SQLite database file (`poetry_repo.db`) and the `poems` table according to the schema defined above.

2.  **Step 2: API Development**
    *   Initialize a new FastAPI project.
    *   Implement the database connection logic to the SQLite file.
    *   Create the Pydantic models for data validation.
    *   Build the API endpoints (`/poems`, `/poems/{poem_uuid}`, `/search`, `/tags`) as specified.

3.  **Step 3: `vpsweb` Integration**
    *   Create a new module within `vpsweb` (e.g., `database_writer.py`).
    *   This module will contain a function that takes the final translated poem object and its metadata as input and writes it to the SQLite database.

4.  **Step 4: Web UI Development**
    *   Set up a new project using either **Pelican** or **Hugo**.
    *   Create the necessary page templates (homepage, poem detail page).
    *   Develop a build script to fetch data from the API and generate the static pages.
    *   Implement the search page with client-side JavaScript to fetch and display results from the API.

5.  **Step 5: Deployment**
    *   **API:** Deploy the FastAPI application using a service like Render, Heroku, or a small cloud VM.
    *   **Web UI:** Deploy the generated static site to a service like Netlify, Vercel, or a simple object storage bucket (e.g., AWS S3).

## 6. Future Considerations

*   **Admin Panel:** A simple web interface for manually editing or deleting poem records.
*   **Advanced Search:** Integration with a more powerful search tool like MeiliSearch if query needs become more complex.
*   **User Accounts:** Allow users to save favorite poems or submit their own translations.