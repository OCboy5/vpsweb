#!/usr/bin/env python3
"""
Repository WebUI WeChat Article Runner

‰∏ìÈó®‰∏∫ repo_webui ÂäüËÉΩÂàÜÊîØÂàõÂª∫ÁöÑÁã¨Á´ãÂæÆ‰ø°ÊñáÁ´†ÁîüÊàêËÑöÊú¨„ÄÇ
‰∏éÁøªËØëÂ∑•‰ΩúÊµÅÂÆåÂÖ®ÂàÜÁ¶ªÔºå‰æø‰∫éÂø´ÈÄüÈöîÁ¶ªÂíåË∞ÉËØïÂæÆ‰ø°ÊñáÁ´†ÁîüÊàêÁõ∏ÂÖ≥ÁöÑÈóÆÈ¢ò„ÄÇ

Usage:
    from vpsweb.webui.utils.wechat_article_runner import WeChatArticleRunner
    runner = WeChatArticleRunner()
    result = runner.generate_from_translation(...)
"""

import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List

# Ê∑ªÂä†Ê†πË∑ØÂæÑ‰ª•Á°Æ‰øùÂèØ‰ª•ÂØºÂÖ•ÂÖ∂‰ªñÊ®°Âùó
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent.parent))

from vpsweb.utils.article_generator import ArticleGenerator, ArticleGeneratorError
from vpsweb.utils.config_loader import load_config
from vpsweb.models.wechat import (
    ArticleGenerationResult,
    ArticleGenerationConfig,
    WeChatArticleStatus,
)
from vpsweb.utils.logger import get_logger

logger = get_logger(__name__)


class WeChatArticleRunner:
    """
    Repository WebUI ‰∏ìÁî®ÁöÑÂæÆ‰ø°ÊñáÁ´†ÁîüÊàêËøêË°åÂô®

    Êèê‰æõÁã¨Á´ã„ÄÅÈöîÁ¶ªÁöÑÂæÆ‰ø°ÊñáÁ´†ÁîüÊàêÂäüËÉΩÔºå‰∏éÁøªËØëÂ∑•‰ΩúÊµÅÂÆåÂÖ®ÂàÜÁ¶ª„ÄÇ
    """

    def __init__(self, config_path: Optional[str] = None):
        """
        ÂàùÂßãÂåñÂæÆ‰ø°ÊñáÁ´†ÁîüÊàêËøêË°åÂô®

        Args:
            config_path: ÈÖçÁΩÆÊñá‰ª∂Ë∑ØÂæÑÔºåÈªòËÆ§‰ΩøÁî® config/default.yaml
        """
        self.config = load_config(config_path)

        # Ê£ÄÊü•ÊòØÂê¶ÊúâÂæÆ‰ø°ÈÖçÁΩÆÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ
        if hasattr(self.config, "wechat") and hasattr(
            self.config.wechat, "article_generation"
        ):
            # ‰ΩøÁî®ÂÆåÊï¥ÁöÑÂæÆ‰ø°ÈÖçÁΩÆ
            wechat_config = self.config.wechat.article_generation.model_dump()
            print("‚úÖ Using WeChat configuration from config")
        else:
            # ‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ
            wechat_config = {
                "include_translation_notes": True,
                "copyright_text": "„ÄêËëó‰ΩúÊùÉÂ£∞Êòé„Äë\nÊú¨ËØëÊñá‰∏éËØëÊ≥®ÂÆåÂÖ®Áî±Áü•Èüµ(VoxPoetica)AIÂ∑•ÂÖ∑ÁîüÊàêÂà∂‰ΩúÔºå‰ªÖ‰æõÂ≠¶‰π†‰∫§ÊµÅ‰ΩøÁî®„ÄÇÂéü‰ΩúÂìÅÁâàÊùÉÂΩíÂéü‰ΩúËÄÖÊâÄÊúâÔºåÂ¶ÇÊúâ‰æµÊùÉËØ∑ËÅîÁ≥ªÂà†Èô§„ÄÇÁøªËØëÂÜÖÂÆπÊú™ÁªèÊéàÊùÉÔºå‰∏çÂæóËΩ¨ËΩΩ„ÄÅ‰∏çÂæóÁî®‰∫éÂïÜ‰∏öÁî®ÈÄî„ÄÇËã•ÈúÄÂºïÁî®ÔºåËØ∑Ê≥®ÊòéÂá∫Â§Ñ„ÄÇ",
                "article_template": "codebuddy",
                "default_cover_image_path": "config/html_templates/cover_image_big.jpg",
                "default_local_cover_image_name": "cover_image_big.jpg",
                "model_type": "non_reasoning",
            }
            print("‚ö†Ô∏è Using default WeChat configuration (config.wechat not found)")

        # ÂàùÂßãÂåñÊñáÁ´†ÁîüÊàêÂô®
        self.article_config = ArticleGenerationConfig(**wechat_config)

        self.article_generator = ArticleGenerator(
            config=self.article_config,
            providers_config=(
                self.config.providers if hasattr(self.config, "providers") else None
            ),
            wechat_llm_config=(
                self.config.providers.wechat_translation_notes.model_dump()
                if hasattr(self.config, "providers")
                and hasattr(self.config.providers, "wechat_translation_notes")
                else None
            ),
            system_config=self.config.model_dump(),
        )

        logger.info("Repository WebUI WeChat Article runner initialized")

    def generate_from_translation(
        self,
        translation_json_path: str,
        output_dir: Optional[str] = None,
        author: Optional[str] = None,
        digest: Optional[str] = None,
        dry_run: bool = False,
        custom_metadata: Optional[Dict[str, Any]] = None,
    ) -> ArticleGenerationResult:
        """
        ‰ªéÁøªËØëJSONÊñá‰ª∂ÁîüÊàêÂæÆ‰ø°ÊñáÁ´†

        Args:
            translation_json_path: ÁøªËØëJSONÊñá‰ª∂Ë∑ØÂæÑ
            output_dir: ËæìÂá∫ÁõÆÂΩï
            author: ÊñáÁ´†‰ΩúËÄÖ
            digest: Ëá™ÂÆö‰πâÊëòË¶Å
            dry_run: ÊòØÂê¶‰∏∫ËØïËøêË°åÊ®°Âºè
            custom_metadata: Ëá™ÂÆö‰πâÂÖÉÊï∞ÊçÆ

        Returns:
            ÊñáÁ´†ÁîüÊàêÁªìÊûú
        """
        try:
            print(
                f"üìÑ Starting WeChat article generation from file: {translation_json_path}"
            )
            logger.info(f"ÂºÄÂßã‰ªéÁøªËØëÊñá‰ª∂ÁîüÊàêÂæÆ‰ø°ÊñáÁ´†: {translation_json_path}")

            print(f"üîß Calling article generator...")
            # ‰ΩøÁî®Áé∞ÊúâÁöÑÊñáÁ´†ÁîüÊàêÂô®
            result = self.article_generator.generate_from_translation(
                translation_json_path=translation_json_path,
                output_dir=output_dir,
                author=author,
                digest=digest,
                dry_run=dry_run,
            )
            print(f"‚úÖ Article generator returned result successfully!")

            # Fix metadata paths and add source_html_path for WebUI usage
            result = self._fix_webui_metadata(
                result, translation_json_path, result.output_directory
            )

            # Custom metadata handling - skip for now since model doesn't support it
            # Note: custom_metadata parameter kept for API compatibility
            print(f"üìù WeChat article generation completed: {result.slug}")
            logger.info(f"ÂæÆ‰ø°ÊñáÁ´†ÁîüÊàêÂÆåÊàê: {result.slug}")
            return result

        except ArticleGeneratorError as e:
            logger.error(f"ÂæÆ‰ø°ÊñáÁ´†ÁîüÊàêÂ§±Ë¥•: {e}")
            raise
        except Exception as e:
            logger.error(f"ÂæÆ‰ø°ÊñáÁ´†ÁîüÊàêËøáÁ®ã‰∏≠ÂèëÁîüÊÑèÂ§ñÈîôËØØ: {e}")
            raise ArticleGeneratorError(f"Unexpected error: {e}")

    def generate_from_translation_data(
        self,
        translation_data: Dict[str, Any],
        output_dir: Optional[str] = None,
        author: Optional[str] = None,
        digest: Optional[str] = None,
        dry_run: bool = False,
        custom_metadata: Optional[Dict[str, Any]] = None,
    ) -> ArticleGenerationResult:
        """
        ‰ªéÁøªËØëÊï∞ÊçÆÂ≠óÂÖ∏ÁîüÊàêÂæÆ‰ø°ÊñáÁ´†

        Args:
            translation_data: ÁøªËØëÊï∞ÊçÆÂ≠óÂÖ∏
            output_dir: ËæìÂá∫ÁõÆÂΩï
            author: ÊñáÁ´†‰ΩúËÄÖ
            digest: Ëá™ÂÆö‰πâÊëòË¶Å
            dry_run: ÊòØÂê¶‰∏∫ËØïËøêË°åÊ®°Âºè
            custom_metadata: Ëá™ÂÆö‰πâÂÖÉÊï∞ÊçÆ

        Returns:
            ÊñáÁ´†ÁîüÊàêÁªìÊûú
        """
        try:
            print(f"üìù Creating temporary JSON file for article generation...")
            # ÂàõÂª∫‰∏¥Êó∂JSONÊñá‰ª∂
            import tempfile

            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".json", delete=False, encoding="utf-8"
            ) as f:
                json.dump(translation_data, f, ensure_ascii=False, indent=2)
                temp_json_path = f.name

            print(f"‚úÖ Temporary JSON file created: {temp_json_path}")

            try:
                print(f"üöÄ Starting article generation from translation data...")
                # ÁîüÊàêÊñáÁ´†
                result = self.generate_from_translation(
                    translation_json_path=temp_json_path,
                    output_dir=output_dir,
                    author=author,
                    digest=digest,
                    dry_run=dry_run,
                    custom_metadata=custom_metadata,
                )
                print(f"‚úÖ Article generation completed successfully!")

                # Fix metadata paths for WebUI usage
                result = self._fix_webui_metadata(
                    result, temp_json_path, result.output_directory
                )

                return result

            finally:
                # Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
                Path(temp_json_path).unlink(missing_ok=True)
                print(f"üßπ Temporary file cleaned up: {temp_json_path}")

        except Exception as e:
            print(f"‚ùå Failed to generate article from data: {e}")
            logger.error(f"‰ªéÁøªËØëÊï∞ÊçÆÁîüÊàêÂæÆ‰ø°ÊñáÁ´†Â§±Ë¥•: {e}")
            raise ArticleGeneratorError(f"Failed to generate article from data: {e}")

    def _fix_webui_metadata(
        self,
        result: ArticleGenerationResult,
        original_json_path: str,
        output_dir: Optional[str],
    ) -> ArticleGenerationResult:
        """
        Fix metadata paths for WebUI usage.

        This method addresses the issues where:
        1. source_json_path points to a temporary file instead of the actual source
        2. source_html_path is missing but needed for browser viewing

        Args:
            result: Original article generation result
            original_json_path: Path to the original translation JSON file (if available)
            output_dir: Output directory where articles were generated

        Returns:
            Updated ArticleGenerationResult with corrected metadata
        """
        try:
            # Load the metadata file
            if not output_dir:
                print("‚ö†Ô∏è No output_dir provided, cannot fix metadata paths")
                return result

            metadata_path = Path(output_dir) / "metadata.json"
            if not metadata_path.exists():
                print(f"‚ö†Ô∏è Metadata file not found: {metadata_path}")
                return result

            # Read current metadata
            with open(metadata_path, "r", encoding="utf-8") as f:
                metadata_dict = json.load(f)

            # Fix source_json_path - remove temporary file path and add meaningful reference
            if "source_json_path" in metadata_dict:
                temp_path = metadata_dict["source_json_path"]
                if temp_path.startswith("/var/folders/") or temp_path.startswith(
                    "/tmp/"
                ):
                    # Replace with meaningful translation reference
                    if "poet_name" in metadata_dict and "poem_title" in metadata_dict:
                        poet = metadata_dict["poet_name"]
                        title = metadata_dict["poem_title"]
                        metadata_dict["source_json_path"] = (
                            f"WebUI Translation: {title} by {poet}"
                        )
                    else:
                        metadata_dict["source_json_path"] = (
                            f"WebUI Translation (generated {datetime.now().strftime('%Y-%m-%d')})"
                        )
                    print(
                        f"üîß Fixed source_json_path: {metadata_dict['source_json_path']}"
                    )

            # Add source_html_path for browser viewing
            html_file_path = Path(output_dir) / "article.html"
            if html_file_path.exists():
                metadata_dict["source_html_path"] = str(html_file_path.absolute())
                print(f"üîß Added source_html_path: {metadata_dict['source_html_path']}")
            else:
                print(f"‚ö†Ô∏è HTML file not found: {html_file_path}")

            # Write updated metadata
            with open(metadata_path, "w", encoding="utf-8") as f:
                json.dump(metadata_dict, f, ensure_ascii=False, indent=2)

            print(f"‚úÖ Updated metadata file with correct paths")

            # Update the result object if needed (Note: ArticleGenerationResult might not have metadata field)
            # This depends on the ArticleGenerationResult structure

            return result

        except Exception as e:
            print(f"‚ö†Ô∏è Failed to fix metadata paths: {e}")
            logger.error(f"Failed to fix metadata paths: {e}")
            # Return original result if fixing fails
            return result

    def batch_generate_articles(
        self,
        translation_files: List[str],
        output_base_dir: Optional[str] = None,
        author: Optional[str] = None,
        dry_run: bool = False,
    ) -> List[Dict[str, Any]]:
        """
        ÊâπÈáèÁîüÊàêÂæÆ‰ø°ÊñáÁ´†

        Args:
            translation_files: ÁøªËØëJSONÊñá‰ª∂Ë∑ØÂæÑÂàóË°®
            output_base_dir: ËæìÂá∫Âü∫Á°ÄÁõÆÂΩï
            author: ÊñáÁ´†‰ΩúËÄÖ
            dry_run: ÊòØÂê¶‰∏∫ËØïËøêË°åÊ®°Âºè

        Returns:
            ÁîüÊàêÁªìÊûúÂàóË°®
        """
        logger.info(f"ÂºÄÂßãÊâπÈáèÁîüÊàêÂæÆ‰ø°ÊñáÁ´†ÔºåÂÖ± {len(translation_files)} ‰∏™Êñá‰ª∂")

        results = []
        for i, translation_file in enumerate(translation_files):
            try:
                logger.info(
                    f"Â§ÑÁêÜÁ¨¨ {i+1}/{len(translation_files)} ‰∏™Êñá‰ª∂: {translation_file}"
                )

                result = self.generate_from_translation(
                    translation_json_path=translation_file,
                    output_dir=output_base_dir,
                    author=author,
                    dry_run=dry_run,
                    custom_metadata={
                        "batch_index": i,
                        "batch_total": len(translation_files),
                    },
                )

                results.append(
                    {
                        "file_index": i,
                        "file_path": translation_file,
                        "status": "success",
                        "result": result,
                    }
                )

            except Exception as e:
                logger.error(f"Á¨¨ {i+1} ‰∏™Êñá‰ª∂Â§ÑÁêÜÂ§±Ë¥•: {e}")
                results.append(
                    {
                        "file_index": i,
                        "file_path": translation_file,
                        "status": "error",
                        "error": str(e),
                    }
                )

        success_count = sum(1 for r in results if r["status"] == "success")
        logger.info(f"ÊâπÈáèÁîüÊàêÂÆåÊàê: {success_count}/{len(translation_files)} ÊàêÂäü")

        return results

    def get_article_summary(self, result: ArticleGenerationResult) -> Dict[str, Any]:
        """
        Ëé∑ÂèñÊñáÁ´†ÁîüÊàêÁªìÊûúÊëòË¶Å

        Args:
            result: ÊñáÁ´†ÁîüÊàêÁªìÊûú

        Returns:
            ÊëòË¶Å‰ø°ÊÅØÂ≠óÂÖ∏
        """
        summary = {
            "slug": result.slug,
            "title": result.article.title,
            "author": result.article.author,
            "digest": result.article.digest,
            "status": result.status.value,
            "output_directory": result.output_directory,
            "html_path": result.html_path,
            "metadata_path": result.metadata_path,
        }

        # ËØóÊ≠å‰ø°ÊÅØ
        summary.update(
            {
                "poem_title": result.article.poem_title,
                "poet_name": result.article.poet_name,
                "source_lang": result.article.source_lang,
                "target_lang": result.article.target_lang,
            }
        )

        # LLM ÊåáÊ†á
        if result.llm_metrics:
            summary["llm_metrics"] = result.llm_metrics

        # Â∞ÅÈù¢ÂõæÁâá‰ø°ÊÅØ
        if (
            hasattr(result.article, "cover_image_path")
            and result.article.cover_image_path
        ):
            summary["cover_image_path"] = result.article.cover_image_path
            summary["show_cover_pic"] = getattr(result.article, "show_cover_pic", False)

        # Ëá™ÂÆö‰πâÂÖÉÊï∞ÊçÆ
        if hasattr(result, "custom_metadata") and result.custom_metadata:
            summary["custom_metadata"] = result.custom_metadata

        return summary

    def validate_translation_file(self, translation_json_path: str) -> Dict[str, Any]:
        """
        È™åËØÅÁøªËØëJSONÊñá‰ª∂ÊòØÂê¶ÈÄÇÂêàÁîüÊàêÂæÆ‰ø°ÊñáÁ´†

        Args:
            translation_json_path: ÁøªËØëJSONÊñá‰ª∂Ë∑ØÂæÑ

        Returns:
            È™åËØÅÁªìÊûúÂ≠óÂÖ∏
        """
        validation_result = {
            "valid": False,
            "errors": [],
            "warnings": [],
            "metadata": {},
        }

        try:
            # Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
            file_path = Path(translation_json_path)
            if not file_path.exists():
                validation_result["errors"].append(
                    f"Êñá‰ª∂‰∏çÂ≠òÂú®: {translation_json_path}"
                )
                return validation_result

            # Â∞ùËØïÂä†ËΩΩJSON
            with open(translation_json_path, "r", encoding="utf-8") as f:
                translation_data = json.load(f)

            # È™åËØÅÂøÖÈúÄÂ≠óÊÆµ
            required_fields = ["workflow_id", "input", "congregated_output"]
            for field in required_fields:
                if field not in translation_data:
                    validation_result["errors"].append(f"Áº∫Â∞ëÂøÖÈúÄÂ≠óÊÆµ: {field}")

            # È™åËØÅËæìÂÖ•Êï∞ÊçÆ
            input_data = translation_data.get("input", {})
            required_input_fields = ["original_poem", "source_lang", "target_lang"]
            for field in required_input_fields:
                if field not in input_data:
                    validation_result["errors"].append(f"ËæìÂÖ•Êï∞ÊçÆÁº∫Â∞ëÂøÖÈúÄÂ≠óÊÆµ: {field}")

            # È™åËØÅËÅöÂêàËæìÂá∫
            congregated = translation_data.get("congregated_output", {})
            required_congregated_fields = ["original_poem", "revised_translation"]
            for field in required_congregated_fields:
                if field not in congregated:
                    validation_result["warnings"].append(f"ËÅöÂêàËæìÂá∫Áº∫Â∞ëÂ≠óÊÆµ: {field}")

            # ÊèêÂèñÂÖÉÊï∞ÊçÆ
            if not validation_result["errors"]:
                original_poem = input_data.get("original_poem", "")
                lines = original_poem.strip().split("\n")
                poem_title = "Êó†È¢ò"
                poet_name = "‰ΩöÂêç"

                for line in lines:
                    line = line.strip()
                    if line and "‰ΩúËÄÖÔºö" not in line and not poem_title:
                        poem_title = line
                    elif "‰ΩúËÄÖÔºö" in line:
                        poet_name = line.split("‰ΩúËÄÖÔºö")[1].strip()
                        break

                validation_result["metadata"] = {
                    "poem_title": poem_title,
                    "poet_name": poet_name,
                    "source_lang": input_data.get("source_lang"),
                    "target_lang": input_data.get("target_lang"),
                    "workflow_id": translation_data.get("workflow_id"),
                }

                validation_result["valid"] = True

        except json.JSONDecodeError as e:
            validation_result["errors"].append(f"JSONÊ†ºÂºèÈîôËØØ: {e}")
        except Exception as e:
            validation_result["errors"].append(f"È™åËØÅËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: {e}")

        return validation_result

    def create_mock_article_result(
        self,
        translation_json_path: str,
        custom_metadata: Optional[Dict[str, Any]] = None,
    ) -> ArticleGenerationResult:
        """
        ÂàõÂª∫Ê®°ÊãüÁöÑÊñáÁ´†ÁîüÊàêÁªìÊûúÔºàÁî®‰∫éÊµãËØïÔºâ

        Args:
            translation_json_path: ÁøªËØëJSONÊñá‰ª∂Ë∑ØÂæÑ
            custom_metadata: Ëá™ÂÆö‰πâÂÖÉÊï∞ÊçÆ

        Returns:
            Ê®°ÊãüÁöÑÊñáÁ´†ÁîüÊàêÁªìÊûú
        """
        # È™åËØÅÊñá‰ª∂Âπ∂ÊèêÂèñÂÖÉÊï∞ÊçÆ
        validation = self.validate_translation_file(translation_json_path)

        if not validation["valid"]:
            raise ArticleGeneratorError(
                f"Invalid translation file: {', '.join(validation['errors'])}"
            )

        metadata = validation["metadata"]

        # ÂàõÂª∫Ê®°ÊãüÊñáÁ´†
        from vpsweb.models.wechat import WeChatArticle

        mock_article = WeChatArticle(
            title=f"„ÄêÁü•ÈüµËØëËØó„Äë{metadata['poem_title']}Ôºà{metadata['poet_name']}Ôºâ",
            content="<p>ËøôÊòØÊ®°ÊãüÁîüÊàêÁöÑÊñáÁ´†ÂÜÖÂÆπ</p>",
            digest="ËøôÊòØÊ®°ÊãüÁîüÊàêÁöÑÊñáÁ´†ÊëòË¶Å",
            author="Repository WebUI",
            poem_title=metadata["poem_title"],
            poet_name=metadata["poet_name"],
            source_lang=metadata["source_lang"],
            target_lang=metadata["target_lang"],
            translation_workflow_id=metadata["workflow_id"],
            translation_json_path=translation_json_path,
        )

        # ÂàõÂª∫Ê®°ÊãüÁªìÊûú
        mock_result = ArticleGenerationResult(
            article=mock_article,
            html_path="",  # Ê®°ÊãüË∑ØÂæÑ
            metadata_path="",  # Ê®°ÊãüË∑ØÂæÑ
            slug=f"mock-{metadata['poet_name']}-{metadata['poem_title']}",
            output_directory="",
            status=WeChatArticleStatus.GENERATED,
            llm_metrics={
                "mock": True,
                "tokens_used": 0,
                "cost": 0,
            },
        )

        # Ê∑ªÂä†Ëá™ÂÆö‰πâÂÖÉÊï∞ÊçÆ
        if custom_metadata:
            mock_result.custom_metadata = custom_metadata

        return mock_result


# ‰æøÊç∑ÂáΩÊï∞Ôºå‰æõÁõ¥Êé•‰ΩøÁî®
def quick_generate_article(
    translation_json_path: str,
    author: Optional[str] = None,
    dry_run: bool = False,
) -> ArticleGenerationResult:
    """
    Âø´ÈÄüÁîüÊàêÂæÆ‰ø°ÊñáÁ´†ÁöÑ‰æøÊç∑ÂáΩÊï∞

    Args:
        translation_json_path: ÁøªËØëJSONÊñá‰ª∂Ë∑ØÂæÑ
        author: ÊñáÁ´†‰ΩúËÄÖ
        dry_run: ÊòØÂê¶‰∏∫ËØïËøêË°åÊ®°Âºè

    Returns:
        ÊñáÁ´†ÁîüÊàêÁªìÊûú
    """
    runner = WeChatArticleRunner()
    return runner.generate_from_translation(
        translation_json_path=translation_json_path,
        author=author,
        dry_run=dry_run,
    )


def validate_translation_file(translation_json_path: str) -> Dict[str, Any]:
    """
    È™åËØÅÁøªËØëÊñá‰ª∂ÁöÑ‰æøÊç∑ÂáΩÊï∞

    Args:
        translation_json_path: ÁøªËØëJSONÊñá‰ª∂Ë∑ØÂæÑ

    Returns:
        È™åËØÅÁªìÊûúÂ≠óÂÖ∏
    """
    runner = WeChatArticleRunner()
    return runner.validate_translation_file(translation_json_path)
